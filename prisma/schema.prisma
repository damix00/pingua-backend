// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}


// Application characters
enum AppCharacter {
  PINGUA // Our mascot

  // Human characters for the AI
  ANNA
  JOSEPH
  MICHAEL
  PETER
  DAVID
}

enum Plan {
  FREE
  BASIC
  PREMIUM
  ULTRA
}

model User {
  id               String    @id @default(auto()) @map("_id") @db.ObjectId
  email            String    @unique
  username         String    @unique
  avatar           String?
  name             String
  xp               Int       @default(0)
  plan             Plan      @default(FREE)
  planExpiresAt    DateTime?
  resetToken       String    @default(uuid())
  createdAt        DateTime  @default(now())

  // Fields for daily streak tracking
  currentStreak    Int       @default(0)
  longestStreak    Int       @default(0)
  lastStreakUpdate DateTime?

  courses          Course[]
  aiConversations  AIConversation[]
}

// Auth

enum VerificationStatus {
  PENDING
  VERIFIED
  CREATING // creating means that this verification code is being used to create a new user
}

model VerificationCode {
  id        String        @id @default(auto()) @map("_id") @db.ObjectId
  ip        String?
  code      String        @unique
  email     String
  status    VerificationStatus
  createdAt DateTime      @default(now())
  expiresAt DateTime
}

model Course {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  userId String @db.ObjectId
  languageCode String // The language code of the course
  appLanguageCode String // The language code of the app, so we can show the course in the user's language
  xp Int
  level Int
  fluencyLevel Int
  // In case we update the course, we can increment the version
  // The user will still be on the old version, but new users will get the new version
  version Int @default(1)
  
  user User @relation(fields: [userId], references: [id])
  sections Section[]
  questions UnitQuestions[]
}

model Section {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  courseId String @db.ObjectId
  finished Boolean // Index this so we can quickly get the unfinished section
  level Int
  accessible Boolean

  course Course @relation(fields: [courseId], references: [id])
  questions UnitQuestions[]
  
  @@index([finished])
}

model UnitQuestions {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  courseId String @db.ObjectId
  sectionId String @db.ObjectId
  xp Int

  course Course @relation(fields: [courseId], references: [id])
  section Section @relation(fields: [sectionId], references: [id])
}

enum QuestionType {
  Flashcard
  MultipleChoice
  ListenAndWrite
  ListenAndChoose
  RecordVoice
  Translate
}

enum QuestionDifficulty {
  EASY
  MEDIUM
  HARD
}

model Question {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  question String
  answer String
  xp Int
  level Int
  languageCode String
  appLanguageCode String
  type QuestionType
  difficulty QuestionDifficulty
  image String?
  audio String?
  video String?
  createdAt DateTime @default(now())
}

model AIConversation {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  userId String @db.ObjectId
  character AppCharacter

  // AI will extract key information from the conversation and store it here
  // This is because it's not possible to fit the entire conversation in the prompt
  // Plus, this will make it feel more like a real conversation
  memories String[]

  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  messages AIConversationMessage[]
}

enum MessageType {
  TEXT
  VOICE
  IMAGE // The user can send an image and the AI can interpret it, using GPT-4
}

model AIConversationMessage {
  id String @id @default(auto()) @map("_id") @db.ObjectId
  conversationId String @db.ObjectId
  userMessage Boolean // If the user sent the message, or the AI
  messageContent String
  messageType MessageType
  contentUrl String[] // If the message is an image or voice, the URL(s) will be stored here

  createdAt DateTime @default(now())

  conversation AIConversation @relation(fields: [conversationId], references: [id])
}
